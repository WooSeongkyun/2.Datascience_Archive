# 자료형: 사전형 / 집합형

상태: 연산 / 자료형

### 1.사전 자료형 $dictionary$

- 순서를 가지고 있지 않다 ⇒ 인덱싱과 슬라이싱이 안된다
- 키-값을 매핑시키는 자료형으로 순서-값으로 매칭되는 리스트나 튜플과 대비된다
- $dict=\{key_1:val_1, key_2:val_2,...,key_n,val_n\}$ 꼴로 이루어짐
- 키$key$로써 리스트나 튜플이 사용될 수 없다
- 값$value$로써 리스트나 튜플, **함수**가 올 수 있다

### 1-1. 사전 자료형 생성법

- $a=\{key_1:val_1, key_2:val_2,...,key_n,val_n\}$ 꼴로 지정
- $a= \{key_1=val_1,key_2=val_2,...,key_n=val_n\}$ 꼴로 지정
    - 이 경우 $key_1,key_2,...,key_n$은 ‘’(따음표)를 안써도 자동으로 문자로 인식한다
- $a=$ $dict([[key_1,val_1],[key_2,val_2],...,[key_n,val_n]])$
- $keys=[key_1,key_2,...,key_n] ,\,\,vals=[val_1,val_2,...,val_n]$ 지정 후
    - $a=dict(zip(keys,vals))$

### 1-2 사전 함수

- 사전 $a=\{key_1:val_1, key_2:val_2,...,key_n,val_n\}$ 가 있다하자
- 사전에 원소 추가
    - $a[key_{new}]=val_{new}$ 하면 새로운 원소쌍이 생긴다
- 원소 제거
    - $del \,\,a[key]$
- 원소 모두 제거
    - $a.clear()$
- 키 리스트 보기
    - $a.keys()$
    - $dict\_keys$  라는 자료형임
- 값 리스트 보기
    - $a.values()$
    - $dict\_values$ 라는 자료형임
- 키와 값 쌍으로 얻기
    - $a.items()$
- 키로 값 얻기
    - $a.get(key)$
    - 존재하지 않는 $key$을 입력할 시 $none$을 출력한다
- 해당 키가 사전 안에 있는지 확인하기
    - $print(key \,\,in\,\,a)$
        - 해당 키가 존재하면 $True$ 없으면 $False$ 가 뜬다

### 2. 집합 자료형 $set$

- 수학적 집합과 유사한 정의. 데이터를 원소로 하는 집합
    - 중복을 허용하지 않는다
    - 순서가 존재하지 않는다
    - 집합을 생성할 떄 중괄호{} 를 사용하진 않지만 표기는 중괄호로 된다
    

### 2-1 집합 자료형 생성법

- $a=set([x_1,x_2,...,x_n])$ $or \,\,set((x_1,x_2,...,x_n))$로 만든다
- $a=set(['str'])$이 들어가는 경우 $str$의 글자단위로 쪼개지어 저장된다. 이때 중복이 삭제되고 순서는 고려되지 않는다
- $a=frozenset([x_1,x_2,...,x_n]) \,\,or\,\,frozenset((x_1,x_2,...,x_n))$ 으로 생성하면 변경불가능한 집합을 생성할 수 있다

### 2-2.집합의 함수

- $a=set((x_1,x_2,...,x_n))$ 이고 $b=set((y_1,y_2,...,y_m))$이라 하자
- 교집합
    - $a \,\& b$
    - $a.intersection(b)$
- 합집합
    - $a |b$
    - $a.union(b)$
- 차집합
    - $a-b$
    - $a.difference(b)$
- 원소 한개 추가
    - $a.add(x)$
- 원소 여러개 추가
    - $a.update((x_1,x_2,..,x_n))\,\,or\,\,a.update([x_1,x_2,...,x_n])$
- 원소 제거 (값에 따른)
    - $a.remove(x)$