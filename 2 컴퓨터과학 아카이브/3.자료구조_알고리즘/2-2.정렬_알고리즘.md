## 1. 정렬 알고리즘
- 정렬 알고리즘 종류
	1. 버블 정렬 Bubble Sort
	2. 단순 선택 정렬  Straight Selection Sort
	3.  단순 삽입 정렬 Straight Insertion Sort
	4.  셸 정렬 Shell Sort
	5.  퀵 정렬 Quick Sort
	6.  병합 정렬 Merge Sort
	7.  힙 정렬 heap Sort (미완)
- 정렬 알고리즘의 안정성
	- 안정된 알고리즘 stable algorithm : 같은 값을 가지고 있는 원소의 순서가 정렬 후에도 그 순서가 바뀌지 않는 정렬 알고리즘
- 정렬 알고리즘의 기본
	- 교환, 선택, 삽입

## 2. 정렬 알고리즘의 종류들

### 1.버블 정렬 $bubble\,\,sort$: 단순교환정렬

- 이웃한 두 원소의 대소 관계를 비교하여 교환을 반복하는 알고리즘이다
- 시간복잡도: $O(n^{2})$ 

 - 알고리즘 구현
	- 조건
		- 배열 $[x_1,x_2,...,x_n]$ 이 있다하자
	- 순서
		- 첫번째 패스 
			- 맨 처음 가장 오른쪽 원소$x_n$가 옆 왼쪽 원소$x_{n-1}$와 크기를 비교한다  
				- 만약 $x_{n-1}>x_{n}$ 이라면 교환하고, 아니면 교환하지 않는다
			- 이 비교는 이제 다음 $x_{n-1}$ 과 $x_{n-2}$에서 시행한다
			- 비교를 계속 반복하여 $x_{2}$와 $x_{1}$ 까지 반복한다
			- 이 결과 가장 작은 원소가 $x_1$ 에 도착한다
		- 두번째 패스
			- 맨 처음 가장 오른쪽 원소$x_n$가 옆 왼쪽 원소$x_{n-1}$와 크기를 비교한다  
				- 만약 $x_{n-1}>x_{n}$ 이라면 교환하고, 아니면 교환하지 않는다
			- 이 비교는 이제 다음 $x_{n-1}$ 과 $x_{n-2}$에서 시행한다
			- 비교를 계속 반복하여 $x_{3}$와 $x_{2}$ 까지 반복한다
			- 이 결과 두번째로 작은 원소가 $x_2$ 에 도착한다
		- 패스 반복 시행
		- n-1 패스
			- 맨 처음 가장 오른쪽 원소$x_n$가 옆 왼쪽 원소$x_{n-1}$와 크기를 비교한다  
				- 만약 $x_{n-1}>x_{n}$ 이라면 교환하고, 아니면 교환하지 않는다
			- 이 결과 모든 정렬이 끝난다
	- 연산량
		- 결론적으로 총 비교시행횟수는 $\cfrac{n(n-1)}{2}$
		- 총 원소교환횟수는 평균 $\cfrac{1}{2}$ 를 곱하여 $\cfrac{n(n-1)}{4}$이 된다
	- 코드

```python
# 버블 정렬
from typing import MutableSequence

def bubble_sort(a: MutableSequence) -> None:
    #배열의 길이
    n= len(a)

    for i in range(n-1):
        #(n,n-1,...,1), (n,n-1,...,2), ,..., (n,n-1) 로 출력됨 
        for j in range(n-1,i,-1):
            if a[j-1] > a[j]:
                a[j-1] , a[j] = a[j], a[j-1]

```

- 버블정렬 개선 1.
```python 
from typing import MutableSequence

# 특정 패스에서 교환이 한번도 안일어날시 종료
def buble_sort2(a: MutableSequence) -> None: 
    
    n= len(a)
    for i in range(n-1):
        exchange= 0 
        for j in range(n-1,i,-1):
            if a[j-1] > a[j]:
                a[j-1], a[j] = a[j], a[j-1]
                exchange +=1 
	        # 특정 패스에서 교환이 한번도 안일어날시 종료
        if exchange == 0:
            break 

```

- 버블정렬 개선2.

``` python
# 버블정렬 개선 2: 마지막에서 교환된 위치를 기억하여 그 위치를 포함한 왼쪽 영역을 검색에서 제외하는 방법
from typing import MutableSequence

def bubble_sort3(a: MutableSequence) -> None:
    #배열의 길이
    n= len(a)
    k=0 
    #k가 마지막에 정렬된 위치므로 n-1까지 정렬되면 다 정렬된 것
    while k < n-1: 
        last = n-1 
        #k를 왼쪽 경계로 함
        for j in range(n-1,k,-1):
            if a[j-1] > a[j]:
                a[j-1] , a[j] = a[j], a[j-1]
                last = j 
        #가장 최근에 교환된 위치 j를 k에 저장
        k = last 

```
- 셰이커 정렬 Shaker Sort 
```python
#버블 정렬3: 셰이커 정렬,
# 홀수 패스에선 가장 작은 원소를 맨앞으로, 짝수  패스에선 가장 큰 원소를 맨 뒤로 보내는 것을 번갈아가며는 정렬 

from typing import MutableSequence

def shaker_sort(a:MutableSequence) -> None: 
    #좌경계값
    left = 0
    #우경계값
    right= len(a) -1 
    last= right 
    while left < right : 
        for j in range(right,left,-1) : 
            if a[j-1] > a[j]:
                a[j-1] , a[j] = a[j] , a[j-1]
                last= j 
        #마지막으로 정렬된 위치를 last 으로 하여 left에 저장, 좌경계값을 수정한다
        left= last 
       
            
        for j in range(left,right) : 
            if a[j] > a[j+1]:
                a[j],a[j+1] = a[j+1], a[j]
                last= j 
        #마지막으로 정렬된 위치를 last 으로 하여 right에 저장, 우경계값을 수정한다
        right = last 

```

### 2.: 단순 선택 정렬 straight selection sort
- 가장 작은 원소부터 시작해 알맞은 위치로 옮기는 작업을 반복하며 정렬하는 방법이다
- 이 알고리즘은 서로 이웃하지 않는 원소들을 교환하므로 불안정한 알고리즘이다
- 선택정렬의 시간복잡도: $O(n^2)$
 - 알고리즘 구현
	 - 조건
		 - 배열 $[x_1,x_2,...,x_n]$ 이 있다하자
	 - 순서
		 - 첫번째 패스
			 - 1번째로 작은 원소를 찾는다
			 - 0번째  위치 원소와 교환한다
		 - 두번째 패스
			 - 2번째로 작은 원소를 찾는다
			 - 1번째 위치 원소와 교환한다
		 - 패스 반복 시행
		 - n-1번째 패스 시행
			 - n-1번째로 작은 원소를 찾는다
			 - n-2번째 위치 원소와 교환한다
	 - 코드

```python
#단순 선택 정렬
from typing import MutableSequence

def selection_sort(a : MutableSequence) -> None: 
    n = len(a)
    for i in range(n-1):
        #맨처음 교환될 위치의 원소의 인덱스이자, 탐색 영역내에서 가장 작은 원소의 인덱스이다
        min = i 
        # i+1(맨 처음을 1로 보자)번째 패스에선 i이하의 수는 이미 정렬된 수다
        for j in range(i+1,n) : 
            if a[j] < a[min]:
                min= j
        #i+1 번째 패스 마지막 단계에서 탐색 영역서 가장 작았던 원소와 i번째 원소를 교환시킨다
        a[i],a[min] = a[min],a[i]

```

### 3. 단순삽입정렬$straight\,\,insertion\,\,sort$ 이란?

- 알고리즘을 비정렬된 영역, 정렬된 영역으로 구분지어, 비정렬된 부분의 가장 왼쪽 원소를 정렬된 영역의 원소들과 크기 비교후, 정렬된 영역이 계속 정렬될 수 있겠금 적절한 위치에 넣는 방법이다
- 시간복잡도: 최선의 경우 $O(n)$ 최악의 경우 $O(n^2)$
 - 알고리즘 구현
	 - 조건
		 - 배열 $[x_1,x_2,...,x_n]$ 이 있다하자
	 - 순서
		 - 첫번째 패스
			 두번째 원소 $x_{2}$를  첫번째 원소 $x_{1}$ 과 크기 비교후 정렬이 될수 있게 끔 $x_{1}$ 의 왼쪽 또는 오른쪽 그대로 둔다 
		 - 두번째 패스
			 - 세번째 원소 $x_{3}$ 를 정렬된 영역 $[x_{1},x_{2}]$ 를 $x_{2},x_{1}$ 순으로 크기를 비교해가면서 정렬이 될 수 있겠끔 $[x_{1},x_{2}]$ 속 또는 왼쪽, 오른쪽에 둔다
		 - 패스 반복 시행
		 - n-1번째 패스 시행
			 - n번째 원소 $x_{n}$ 를 정렬된 영역 $[x_{1},x_{2},...,x_{n}]$ 를 $x_{n-1},x_{n-2},...x_{1}$ 순으로 크기를 비교해가면서 정렬이 될 수 있겠끔 $[x_{1},x_{2},...,x_{n-1}]$ 속 또는 왼쪽, 오른쪽에 둔다
	 - 코드
```python
from typing import MutableSequence

def insertion_sort(a: MutableSequence) -> None:
    n= len(a)
    # a[i] :비정렬된 배열속 주목된 노드. 정렬된 배열원소와 크기를 비교한 후  삽입한다
    for i in range(1,n):
        j = i
        tmp= a[i]
        #정렬된 노드 가장 오른쪽부터 a[i]와 비교를 시작하여, a[i]보다 큰 노드를 만날때까지 서로 교환한다
        #이때 첫번째 교환에서 a[i]값이 a[i-1]로 대체됨에 따라 기존 값은 삭제되는데 tmp가 저장하고 있다
        while j > 0 and a[j-1] > tmp:
            a[j] = a[j-1]
            j -=1
        a[j]= tmp 

```

### 4. 셸 정렬 Shell Sort
- 배열을 반복하여 2분할 하여, 각각 왼쪽 부분배열과 오른쪽 부분배열의 같은 순서의 원소 크기를 비교하여 왼쪽이 오른쪽 원소보다 값이 클시 교환하는 과정을 반복하여 정렬하는 알고리즘이다
- 떨어져 있는 원소를 교환하므로 불안정 정렬이다
- 시간복잡도:  최선은 $O(n)$ 평균은 $O(n^{1.5})$ 이다
 - 알고리즘 구현
	 - 조건
		 - 배열 $[x_1,x_2,...,x_n]$ 이 있다하자
	 - 순서
		 - 첫번째 패스
			 - $h=n//2$ 의 크기로 배열을 쪼갠다
			 - 각각 위치가 $h$ 간격만큼 차이나는 원소끼리 값을 비교합니다. 왼쪽 원소가 오른쪽 원소보다 크면 교환합니다.
			 - 그 결과 길이가 2개인 부분배열들은 배열내에서 정렬된다
		 - 두번째 패스
			 - $h=n//2^2$ 의 크기로 배열을 쪼갠다
			 - 각각 위치가 $h$ 간격만큼 차이나는 원소끼리 값을 비교합니다. 왼쪽 원소가 오른쪽 원소보다 크면 교환합니다.
			 - 그 결과 길이가  4인 부분배열들은 배열내에서 정렬된다
		 - 패스 반복 시행
		 - n-1번째 패스 시행
			 - $h=n//2^{\log_{2}{n}}$ 의 크기로 배열을 쪼갠다
			 - 각각 위치가 $h$ 간격만큼 차이나는 원소끼리 값을 비교합니다. 왼쪽 원소가 오른쪽 원소보다 크면 교환합니다.
			 - 그 결과 길이가 $n$ 인 전체 배열은 배열내에서 정렬이 완료된다
	 - 코드

``` python 
from typing import MutableSequence

# 셸 정렬
from typing import MutableSequence

# 셸 정렬
from typing import MutableSequence

# 셸 정렬
def shell_sort(a: MutableSequence) -> None: 
    # 배열의 길이 
    n= len(a)
    # 맨처음 배열을 이등분하여 부분배열을 만든다
    h= n//2 
    while h>0:
        #각 부분배열에서 같은 순서의 인덱스를 i,j라 한다
        #여기서 크기 2가 되는 부분배열 한번 정렬하고 나면 h //=2로 크기기가 절반이 되어 4,8,...,n으로 점차 바뀐다
        for i in range(h,n):
            j= i -h 
            #임시로 오른쪽 부분배열의 값을 저장해둔다
            tmp = a[i]
            
            '''while 루프  
            맨 처음엔 부분배열의 오른쪽 경계과 오른쪽에서 두번째 원소를 비교한다. 만약 두번째 원소가 경계값 보다 크다면
            두 위치를 교환한다 
            그다음엔  j값을 h만큼 뺴면서 왼쪽을 전진하며 원소들을 비교한다'''
            while j >=0 and a[j] > tmp: 
                #오른쪽 원소에 왼쪽 원소값을 저장하라
                a[j+h] = a[j]
                #왼쪽 원소 인덱스에 h 만큼 빼라
                j -= h
            # 왼쪽 원소값이 오른쪽 원소값보다 크다면 j -=h가 적용, 왼쪽 원소에 오른쪽 원소값이 저장
            # 왼쪽 원소값이 오른쪽 원소값보다 작다면 오른쪽 원소에 임시 저장된 오른쪽 원소값이 저장
            a[j+h]= tmp 
            #h //2^k 로 계속 잘게 쪼게어지며 반복
        h //= 2
```

- 개선된 셸 정렬 알고리즘
    - $2^n$으로 나누는 것 대신 다음과 같은 수열 $3x+1$ 로 나누는것이 연산속도가 더 빠르다고 알려져 있다

### 5. 퀵정렬 Quick Sort

- 피벗 $pivot$ 이란 분할의 기준이 되는 원소를 정해  배열을 이분할한뒤 피봇보다 작은 값을 왼쪽 부분 배열에, 피봇보다 큰 값을 오른쪽 부분 배열에 위치시키고, 계속하여 이분할시켜 정렬하는 방법이다
- 서로 이웃하지 않은 원소를 교환하므로 불안정 정렬이다
- 시간 복잡도: $O(n\cdot log\,n)$으로 많은 상황에서 가장 빠른 알고리즘으로 알려져 있으나, 매번 1개와 나머지 원소로 그룹이 나눠지는 경우 시간 복잡도는 $O(n^2)$가 될 수 있다
 - 알고리즘 구현
	 - 조건
		 - 배열 $[x_1,x_2,...,x_n]$ 이 있다하자
		 - 왼쪽 포인터를 `pl` 오른쪽 포인터를 `pr`, 피봇을 `pivot` 이라 하자 
	 - 순서
		 - 재귀식 알고리즘
			 - 피봇을 정한다. ( 이 책에선 배열의 중앙값을 피봇으로 한다)
			 - 왼쪽 포인터보다 오른쪽 포인터가 큰 경우 계속하여
				 - 피봇보다  큰 왼쪽 값을 찾을 때 까지 오른쪽으로 전진하고
				 - 피봇보다  작은 오른쪽 값을 찾을 때 까지 왼쪽으로 전진한다
				 - 만약 발견될 시 두 원소의 위치를 교환한다
			 - 교환이 다끝나고 왼쪽이나 오른쪽 포인터중 하나가 피봇에 도달하고, 왼쪽과 오른쪽 포인트를 교환하여 오른쪽 포인터, 왼쪽 포인터순으로 위치하고, 둘중 하나는 피벗의 위치이다. 
		 - 이때 각각의 포인터를 기준으로 이분할하는 재귀식을 실행한다
		 - 2개 또는 1개의 부분배열들도 퀵 정렬이 되면 정렬이 종료된다
	 - 코드

```python
from typing import MutableSequence

def quick_sort(a: MutableSequence) -> None:

    #각각 배열 원본, 나누어지는 부분 배열의 왼쪽 경계 원소, 오른쪽 경계 원소가 argument로 들어간다
    def qsort(a: MutableSequence, left:int , right : int ) -> None: 
        #왼쪽 포인터, 오른쪽 포인터,피봇을 argument에서 입력받는 값으로 지정한다
        pl= left 
        pr= right 
        pivot = a[(left+right)//2]

        #배열을 나누는 구간 출력
        print(f'a[{left}] ~ a[{right}]:', *a[left:right+1])

        # 만약 오른쪽 포인터가 왼쪽 포인터보다 크거나 같으면 
        while pl <= pr : 
             #피봇 값보다 큰 왼쪽 원소를 찾을 때 까지 오른쪽으로 이동
             #피봇 값보다 작은 오른쪽 원소를 찾을 때 까지 왼쪽으로 이동
            while a[pl] < pivot: pl +=1 
            while a[pr] > pivot: pr -=1 
            #만약 왼쪽이나 오른쪽 포인터가 피봇을 넘어 이동하지 않았다면 
            if pl <= pr : 
                # 두 원소를 교환한다
                a[pl], a[pr] = a[pr], a[pl]
                #한칸 앞으로 포인터를 이동시킨다
                pl += 1 
                pr -=1 

        ''' 이때 한번 검색이 끝나면 오른쪽이나 왼쪽에 피벗에 도착하고, 그 상태에서 교환이 이루어 지므로 
            오른쪽 포인터, 왼쪽 포인터순으로 위치하고 둘중 하나는 피벗에 위치하는 모양새이다
            그 상태에서 재귀식을 통해 이분할된 부분배열을 계속 이분할하는 형식으로 퀵 정렬을 반복한다'''
        if left < pr : qsort(a,left,pr)
        if pl <right: qsort(a,pl,right)

    qsort(a,0,len(a)-1)
    

```


### 6. 정렬: 병합 정렬

- 배열을 반복적으로 두 배열로 나누고, 두 배열에서 주목하는 원소값을 비교하면서 작은 쪽을 꺼내 새로운 배열에 저장하면서 정렬하는 방식이다. 
- 서로 떨어진 원소를 교환하는게 아니므로 안정적이다
- 시간복잡도:   $O(n \log_{}{n})$
 - 알고리즘 구현
	 - 조건
		 - 배열 $[x_1,x_2,...,x_n]$ 이 있다하자
	 - 순서
		 - 재귀식을 배열의 중앙값을 기준으로 이분할하여 재귀식 알고리즘을 시행한다
		 - 재귀식 알고리즘
			 - 이때 왼쪽 부분배열을 임시저장 배열에 저장한다
			 - 임시저장 배열과 오른쪽 부분 배열을 각 포인터를 좌경계값으로 시작하여, 크기를 비교하기 시작한다. 두쪽중 크기가 작은 값을 새 배열값에 입력하고, 포인터는 한칸씩 계속 전진한다
			 - 임시저장배열에 남은 원소가 있으면 차례대로 새 배열에 입력한다
		 - 왼쪽 분할정렬이 먼저 병합되고, 오른쪽 분할정렬이 병합되어, 최종적으로 합쳐진 정렬배열이 반환된다
	 - 코드

```python
#책버전
from typing import MutableSequence 

def merge_sort(a :MutableSequence ) -> None: 

    def merge_sort_internal( a: MutableSequence, left: int ,right: int )  -> None: 
        if left <right : 
            #중앙값 설정
            center= (left+right) // 2 
            #재귀식: center를 중심으로 이분할을 반복
            merge_sort_internal(a,left,center)
            merge_sort_internal(a,center+1,right)

            p = j = 0 
            i= k= left 

            # 왼쪽 부분배열(좌경계 포인터와 중앙값 사이)를 임시저장 배열 buff에 저장
            
            while i <= center:
                buff[p] = a[i]
                p += 1
                i += 1
            
            '''오른쪽 부분배열과 임시저장 배열 buff를 다시 배열로 병합한다
             k는 병합되는 배열의 포인터
             j는 임시저장 배열의 포인터로 활용됨 , i는 기존 배열의 포인터
             '''
             # 기존 배열 포인터와 임시저장 배열 포인터가 각각 오른쪽 끝단에 도달하지 않으면
            while i <= right and j<p:
                # 임시저장 배열 buff의 원소와 기존 배열 원소와 그 크기를 비교하였을떄, 기존배열 원소가 더 크면
                if buff[j] <= a[i]:
                    #새로운 배열에 임시저장 배열값을 저장한다
                    a[k] = buff[j]
                    #임시저장 배열buff  포인터를 오른쪽으로 보내며 탐색을 계속한다
                    j +=1 
                else:
                    #임시저장 배열의 원소와 기존 배열원소와 그 크기를 비교했을때, 임시저장 배열buff 원소가 더 크다면
                    # 새로운 배열에 기존 배열 원소값을 저장한다
                    a[k] = a[i]
                    i += 1 
                #새 배열에 원소가 하나 저장되면 k를 1추가한다
                k +=1 

            #임시저장 배열에 남은 원소가 있으면 순서대로 새로운 배열에 넣기
            while j < p:
                a[k] = buff[j]
                k += 1
                j += 1 
            

    n =len(a)
    #임시저장 배열을 생성
    buff= [None] * n 
    merge_sort_internal(a,0,n-1)
    #임시저장 배열 메모리를 삭제
    del buff 


```


### 7. 힙 정렬

- 힙은 부모의 값이 자식의 값보다 항상 큰 조건을 만족하는 완전 이진 트리이다
    - 이진 트리: 자식 0~2개를 갖고 , 자식이 1개 일땐 왼쪽 부터 채워지는 노드로만 이루어진 트리
    - 완전 이진 트리: 마지막 레벨을 제외하곤 모든 노드의 자식이 2개인 트리
- 부모와 자식의 대소관계는 명확하지만, 형제 사이의 대소관계는 명확하지 않다
- 힙과 배열의 관계
	- 배열에 너비 우선 검색 breath-first search 검색 순으로 선택된 원소를 배열의 왼쪽 부터 오른쪽으로 나열된 원소로 대응시킨다
    - 힙 정렬은 이러한 관계가 성립한다
    - 원소 $a[i]$에 대하여
        - 부모:  $a[(i-1)//2]$
        - 왼쪽 자식:  $a[2i+1]$
        - 오른쪽 자식: $a[2i+2]$
- 시간 복잡도 
	- $n \log_{}{n}$ 
	- 평균, 최선, 최악 모두 일정한 시간 복잡도를 갖는다는 장점이 존재한다
