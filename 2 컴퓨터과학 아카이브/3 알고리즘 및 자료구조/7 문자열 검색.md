# CH7 문자열 검색

## 1. 문자열 검색이란?
- 문자열 검색string searching은 어떤 문자열 안에 다른 문자열이 포함되어 있는지 검색하고, 만약 포함되어 있다면 어디에 위치하는지 찾아내는 방법이다
- 이때 검색되는 쪽의 문자열을 텍스트 text,찾아내는 문자열을 패턴pattern이라고 부른다

## 2.검색법 종류들
### 2-1. 브루트 포스법
- 시간복잡도는 O(mn)이지만 의도적인 패턴이 아니라면 O(n)정도 걸린다
-알고리즘``
```
text= [t_1,t_2,t_3,t_4,...,t_n] 가 있고
pattern=  [p_1,p_2,...,p_m] 가 있다하자

pt: pointer of text
pp: pointer of pattern 이라고 하자
pp=0 일때와 pt=0 일때를 대조한다. 대조가 일치하면
pp=pp+1, pt=pt+1 을 하여 계속 대조를 진행한다
이때 pp != pt 라면 pp는 1부터 시작하고, pt는 0부터 시작하여 다시 대조하기 시작한다
즉 i번째로 대조에 실패한다면 pt는 i부터 시작하고 pp는 0부터 시작하여 대조를 하는 것이다.
이런 대조는 pt=len(text)에 도달하거나(대조할 text의 부분이 pattern보다 짧아서 탐색 실패) 
pp가 len(pattern)에 도달하거나(탐색이 성공)하여 종료한다


```
-  코드
```
#브루트 검색법으로 문자열 검색하기

def BruceForce_Match(text, pattern):
    pt=0 # pt= point of text: text의 커서
    pp=0 # pp = point of pattern: pattern의 커서

  

    while pt !=len(text) and pp!= len(pattern):
        if text[pt] == pattern[pp]:
            pt= pt+1
            pp= pp+1
        else:
            pt= pt-pp+1
            pp=0
    if pp == len(pattern):
        return pt- pp
    else:
        return -1

  
text='우리나라는 삼면이 바다이다'
pattern= '바다'
idx= BruceForce_Match(text,pattern)

if idx == -1:
    print('text 내에 패턴이 존재하지 않습니다')

else:
    print(f'{(idx+1)}번째 문자가 일치합니다')


result)
11번째 문자가 일치합니다
```

### 2-2 KMP법
- 시간복잡도가 최악의 경우에도 O(n)이다 
- 브루트 포스트법에 비해 pt가 앞으로 전진할 뿐 뒤로 되돌아 오지 않는다는 장점을 가지고 있다.
- 그러나 알고리즘 성능이 보이어-무어법보다 같거나 낮은 수준에 불과하여 실제로 잘 사용되진 않는다
- 알고리즘
```
text= [t_1,t_2,t_3,t_4,...,t_n] 가 있고
pattern=  [p_1,p_2,...,p_m] 가 있다하자

pt: pointer of text
pp: pointer of pattern 이라고 하자
pp=0 일때와 pt=0 일때를 대조한다. 대조가 일치하면
pp=pp+1, pt=pt+1 을 하여 계속 대조를 진행한다

이때 pp,pt가 k번째에서 대조가 실패했다고 하자. 그러면 pt뒤의 문자열 부분과, 
pattern[0]부터 시작하는 문자열 부분이 최대한 겹치는 영역을 찾아본다. 그 겹치는 영역의 길이를
j라 하였을 때 pt=k, pp=j로 하여 이미 겹친다고 알고있는 영역은 검사하지 않으면서 검사를 시작한다

```

- 코드
```
# KMP법으로 문자열 검색하기  
def KMP_match(text,pattern):  
    pt=1   # point of text  
    pp=0   # point of pattern  
    skip=[0]* (len(pattern)+1) # 건너뛰기 표  
  
    #건너뛰기표 만들기
	pt와 pp가 일치하지 않을 때 pp가 어디로 이동할지
	정해놓은 표
	skip[j]가 k의 값을 갖는다면 
	lst[0]부터 lst[k-1]까지의 원소와 lst[j]부터 lst[j-k+1]까지의 원소가
	겹친다는 것이다
	
	
    skip[pt]=0  
    while pt != len(pattern):  
        if pattern[pt] == pattern[pp]:  
            pt= pt+1  
            pp=pp+1  
            skip[pt] = pp  
        elif pp==0:  
            pt=pt+1  
            skip[pt]=pp  
        else:  
            pp=skip[pp]  
  
    # 문자열 검색하기  
    pt= pp = 0  
    while pt != len(text) and pp != len(pattern):  
        if text[pt] == pattern[pp]:  
            pt= pt+1  
            pp= pp+1  
        elif pp==0:  
            pt=pt+1  
        else:  
            pp=skip[pp]  
  
    if pp==len(pattern):  
        return pt-pp  
    else:  
        return -1  
  
text='햇빛이 선명하게 나뭇잎을 핥고 있었다'  
pattern='핥고'  
idx= KMP_match(text,pattern)  
  
if idx== -1:  
    print('텍스트 안에 패턴이 존재하지 않습니다')  
else:  
    print(f'{(idx+1)}번째 문자가 일치합니다')
```

### 2-3.보이어-무어법 Boyer-Moor method
- 시간복잡도가 평균 O(n/m), 최악의 경우라도 O(n)이다
- 패턴에 포함되지 않는 문자를 텍스트에서 발견함으로써 포인터를 이동시키는 방식이다
- 알고리즘
```
text= [t_1,t_2,t_3,t_4,...,t_n] 가 있고
pattern=  [p_1,p_2,...,p_m] 가 있다하자

pt: pointer of text
pp: pointer of pattern 이라고 하자
pp와 pt를 대조하여, pt의 문자가 pattern에 포함되지 않는 문자인 경우 pt가 m만큼 이동한다
pp와 pt를 대조하여, pt의 문자가 pattern에서 마지막으로 나오는 위치 인덱스가 k라면
pt는 m-k-1만큼 움직인다


```
- 코드 
```
# Boyer-Moore법으로 문자열 검색  
def Boyer_Moor_match(text,pattern):  
    skip=[None]*256  
  
    #건너뛰기 표 만들기  
    for pt in range(256):  
        skip[pt]=len(pattern)  
    for pt in range(len(pattern)):  
        #하나의 문자를 인자로 받고 해당 문자에 해당하는 유니코드 정수를 반환합니다.  
        skip[ord(pattern[pt])] =len(pattern)-pt-1  
  
    # 검색하기  
    while pt < len(text):  
        pp= len(pattern)-1  
        while text[pt] == pattern[pp]:  
            if pp==0:  
                return pt  
            pt= pt-1  
            pp= pp-1  
        if skip[ord(text[pt])] > len(pattern)-pp:  
            pt=pt+skip[ord(text[pt])]  
        else:  
            pt= len(pattern)-pp  
  
    return -1  
  
  
text=" I'm sitting here in a boring room. it just another rainy sunday afternoon. "  
pattern='rainy'  
idx= Boyer_Moor_match(text,pattern)  
if idx == -1:  
    print('텍스트 내에 패턴이 존재하지 않습니다')  
else:  
    print(f'{(idx+1)}번째 문자가 일치합니다')
```