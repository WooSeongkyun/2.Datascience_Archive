## 추천 시스템 Recommendation System
- 유형 분류
	- 컨텐츠 기반 필터링Content based Filtering
		- 사용자가 특정 아이템을 선호하는 경우 그 아이템과 비슷한 콘텐츠를 가진 다른 아이템을 추천하는 방식
	- 협업 필터링 Collaborative Filtering
		- 메모리 기반 협업 필터링 Memory based Collaborative Filtering 
		- #### 특징
			- 사용자가 아이템에 매긴 평점, 상품 구매 이력등의 사용자 행동 양식 User Behavior를 기반으로 추천해주는 방식
			- 행렬이 굉장히 Sparse하다는 특징이 단점으로 작용한다
		- #### 세부 분류
			- 사용자 기반: 특정 아이템을 구매한 비슷한 고객들이 구매한 아이템을 추천한다
			- 아이템 기반: 특정 아이템을 구매한 고객들은 다음 아이템을 구매했으므로 그 아이템을 추천한다
		- 행렬 분해 협업 필터링 Matrix Factorization Collaborative Filtering
			- 대규모 다차원 행렬을 SVD와 같은 차원 감소 기법으로 분해하는 과정에서 잠재 요인 Latent Factor를 뽑아내는 방법이다
			- 행렬분해는 사용자-아이템 행렬을 사용자-잠재요인/ 아이템-잠재요인 행렬로 분해할 수 있게 한다


## Vote Average의 불공정 해결을 위한 전처리
- 일반적으로 vote수가 적으면 소수의 평가로 인해 매우 높은 점수가 채워질 가능성이 낮지 않다. (예:3개 전부 5점이라고 하면 vote가 5점)그러나 vote수가 많을수록 응당 받아야할 평가로 회귀하는 경향이 있고, 그 결과 vote 평균값이 떨어질 수 있다. 그렇기 때문에 이런 불공정을 보정하고자 데이터 전처리를 해야한다
- imdb에서 전처리한 방법은 다음과 같다 [레퍼런스](https://www.quora.com/How-does-IMDbs-rating-system-work)
	- 관련 용어
		- $R$ : 개별 영화 평점  
		-  $C$ : 전체 영화에 대한 평균 평점
		- $v$ : 개별 영화에 평점을 투표한 횟수  
		- $m$ : 250위 안에 들어야 하는 최소 투표 (정하기 나름인듯. 난 500이라고 하면 500으로 해도 되고.)  
	- 공식
		- $WR(weighted \,\,rating)= (\cfrac{v}{v+m}) * R +(\cfrac{m}{v+m}) * C$

## 콘텐츠 기반 필터링 Content based filtering
- 사용자가 특정 아이템들의 선호를 보여주는 로그기록을 바탕으로,그 아이템들과 비슷한 콘텐츠를 가진 다른 아이템을 추천해주는 방식이다
- 예
	- 코퍼스를 TF-IDF(Term Frequency - Inverse Document Frequency) 처리하여 단어들의 중요들을 정량화하고, 코사인 유사도등의 측정방식으로 추천한다

## 아이템 기반 협업 필터링
- 아이템 소비 기록을 바탕으로 사용자와 비슷한 소비자 유형을 매칭시키고, 해당 유형의 소비자가 어떤 것을 구매했는지 참조함으로서 추천하는 방식
- 아이템간의 속성의 유사도를 고려하는 것이 아니라, 소비자들의 아이템 평가 기록 유사도를 보고 추천하는 것이다
- 예
	- 코퍼스를 코사인 유사도로 계산한다
	- 특정 아이템을 제시했을 떄 그 아이템과 유사한 다른 아이템을 추천 받는다
		- 예) 영화 추천
		- `movie_sim_df["X-Men Origins: Wolverine"].sort_values(ascending=False)[1:10]`

## 행렬 분해 Matrix Factorization 협업 필터링
- 다차원의 매트릭스를 저차원의 매트릭스로 분해하는 행렬 분해 기법(예:SVD)을 활용한다
- $M \times N$ 사용자-아이템 행렬은 $M \times K$ 사용자- 잠재요인, $K \times N$이 잠재요인-아이템 행렬로 쪼갠다
- 예
	- 코퍼스를 사용자- 아이템 행렬로 변환한다
	- 사용자- 아이템 행렬에 SVD 분해를 시행한다
	- scipy를 통해 Truncated SVD 로 근사시킨다. ( scipy.sparse.linalg.svds는 $U,\Sigma,V^t$ 반환값을 제공해주므로 sklearn보다 범용성 있다)
		- 단 $\Sigma$ 의 경우 2차원 행렬대신 대각성분을 모든 벡터로 반환대므로 `np.diag`를 사용해야한다
	- 다음과 같은 함수를 만든다
		- 인자로 사용자 아이디, 영화 정보 테이블, 평점 테이블 등을 받음
		- 사용자 아이디에 SVD로 나온 결과의 영화 평점이 가장 높은 데이터 순으로 정렬
		- 사용자가 본 데이터를 제외
		- 사용자가 안 본 영화에서 평점이 높은 것을 추천
	-  


## 감성분석 응용
- 리뷰를 통해 피드백을 받은 상품을 